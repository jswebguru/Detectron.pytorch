from __future__ import absolute_import
from __future__ import division
from __future__ import print_function
from __future__ import unicode_literals

import cv2
import numpy as np
import os
import pycocotools.mask as mask_util

from model.utils.colormap import colormap

# Use a non-interactive backend
import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt
from matplotlib.patches import Polygon

plt.rcParams['pdf.fonttype'] = 42  # For editing in Adobe Illustrator


_GRAY = (218, 227, 218)
_GREEN = (18, 127, 15)
_WHITE = (255, 255, 255)


def convert_from_cls_format(cls_boxes, cls_segms, cls_keyps):
    """Convert from the class boxes/segms/keyps format generated by the testing
    code.
    """
    box_list = [b for b in cls_boxes if len(b) > 0]
    if len(box_list) > 0:
        boxes = np.concatenate(box_list)
    else:
        boxes = None
    if cls_segms is not None:
        segms = [s for slist in cls_segms for s in slist]
    else:
        segms = None
    if cls_keyps is not None:
        keyps = [k for klist in cls_keyps for k in klist]
    else:
        keyps = None
    classes = []
    for j in range(len(cls_boxes)):
        classes += [j] * len(cls_boxes[j])
    return boxes, segms, keyps, classes


def vis_bbox_opencv(img, bbox, thick=1):
  """Visualizes a bounding box."""
  (x0, y0, w, h) = bbox
  x1, y1 = int(x0 + w), int(y0 + h)
  x0, y0 = int(x0), int(y0)
  cv2.rectangle(img, (x0, y0), (x1, y1), _GREEN, thickness=thick)
  return img


def get_class_string(class_index, score, dataset):
    class_text = dataset.classes[class_index] if dataset is not None else \
        'id{:d}'.format(class_index)
    return class_text + ' {:0.2f}'.format(score).lstrip('0')


def vis_one_image(im, im_name, output_dir, boxes, segms=None, keypoints=None,
                  thresh=0.9, kp_thresh=2,
                  dataset=None, show_class=False,
                  dpi=200, box_alpha=0.0, ext='pdf'):
  """Visual debugging of detections."""
  if not os.path.exists(output_dir):
        os.makedirs(output_dir)

  if isinstance(boxes, list):
    boxes, segms, keypoints, classes = convert_from_cls_format(
        boxes, segms, keypoints)

  if boxes is None or boxes.shape[0] == 0 or max(boxes[:, 4]) < thresh:
    return

  fig = plt.figure(frameon=False)
  fig.set_size_inches(im.shape[1] / dpi, im.shape[0] / dpi)
  ax = plt.Axes(fig, [0., 0., 1., 1.])
  ax.axis('off')
  fig.add_axes(ax)
  ax.imshow(im)

  # Display in largest to smallest order to reduce occlusion
  areas = (boxes[:, 2] - boxes[:, 0]) * (boxes[:, 3] - boxes[:, 1])
  sorted_inds = np.argsort(-areas)

  for i in sorted_inds:
    bbox = boxes[i, :4]
    score = boxes[i, -1]
    if score < thresh:
      continue
    print(dataset.classes[classes[i]], score)
    # show box (off by default, box_alpha=0.0)
    ax.add_patch(
      plt.Rectangle((bbox[0], bbox[1]),
                    bbox[2] - bbox[0],
                    bbox[3] - bbox[1],
                    fill=False, edgecolor='g',
                    linewidth=0.5, alpha=box_alpha))

    if show_class:
      ax.text(
        bbox[0], bbox[1] - 2,
        get_class_string(classes[i], score, dataset),
        fontsize=3,
        family='serif',
        bbox=dict(
            facecolor='g', alpha=0.4, pad=0, edgecolor='none'),
        color='white')

  output_name = os.path.basename(im_name) + '.' + ext
  fig.savefig(os.path.join(output_dir, '{}'.format(output_name)), dpi=dpi)
  plt.close('all')
